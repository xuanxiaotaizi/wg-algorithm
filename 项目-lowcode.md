<!--
 * @Author: wanggang(wanggang220713@credithc.com)
 * @Date: 2024-04-07 08:51:39
 * @LastEditors: wanggang wanggang220713@credithc.com
 * @LastEditTime: 2024-04-17 16:16:14
 * @Description: 
-->

# 市面低代码产品现状
 大部分都是运营、建站类型，缺点：
 1、pro code产物结构复杂，结果就是臃肿的代码影响性能，而且很难二次开发
 2、这种的针对性业务比较强，所以与后端耦合严重，而且数据在别人手里，这是不可接受的

 再说C端，对于营销活动这种类型玩的就是创意设计和业务类型，而且c端用户的特点就是获客成本高，付费意识低下

 那么我们的低代码产品就得：
 1、无缝对接现有的后端接口
 2、业务复用能力、组件使用以及接入门槛
 3、减少对前端现有业务侵入，提供pro code和lesscode模式
 4、拥有自我造血的能力
 5、pro code 可二次开发

 # 设计
 基本和传统的可视化设计一致，采用分层设计

 第一层：协议层scheme,DSL
 第二层：编译器层，根据底层协议填充物料，组件编排#，画布渲染
 第三层：编译器扩展，比如资源管理管理素材，组件管理远程组件，页面管理的发布和保存
 第四层：就是可移植到各个平台搭建服务

# 设计器渲染方案

canvas vs dom
选择dom渲染方案

# scheme设计

版本version
依赖管理(library)
状态管理(store)
数据源(dataSource)
生命周期(lifeCycles)
页面结构(htmlBody)

# 组件与物料设计

基础物料
业务物料
定制化物料
物料的打包需要产出纯净版和平台版，其中平台版的包含组件的属性设置器（组件的描述信息）用于生成scheme，纯净版就是最小渲染单元，真实部署的时候需要部署纯净版代码

物料管理系统：
1、私有物料，npm的方式开发迭代
2、公共物料，托管在物料中心，借助我们内部的cicd高效迭代物料，并提供出npm和cdn资源，这样即可用于低代码平台，也可单独使用，利益最大化

# 拖拽引擎
从0-1实现一个完整的拖拽链路不现实，采用craft.js，为了让物料和craft完全解耦，创建物料会单独提供，一个高阶组件和挂载物料属性方法
编译器要利用iframe的隔离能力，来兼容部分特殊单位在画布中的显示，如 vw、vh 等长度的单位的兼容
采用createPortal挂载，以及react-frame-component，以及微前端的影子环境（避免引用工程中样式，导致样式丢失）

# 编译器逻辑全流程
创建物料：开发一个react组件，包含面板属性以及描述的配置，以及craftjs的封装，可生成纯净版和平台版
注入编辑器：将物料注入编辑器中生成映射
拖拽至frame也就是画布进行编辑
属性设置：一个动态表单，动态渲染组件提供的可配置属性，比如标题，样式，背景等等
存储：将生成的scheme存储至本地一份，远程数据库一份

# 绑定动态逻辑执行的能力
执行js字符串代码逻辑
第一步：通过iframe创建代码执行容器，sandbox属性确保同源和仅能执行js的安全措施
第二步：使用容器内eval执行代码，为了避免全局变量污染，使用with创建新的作用域指向容器内部
第三部：实现类似模版引擎的，正则找到表达式，扔到执行器执行拿到结果

# scheme保存

本地保存：indexDB，适当的采用lru缓存策略
远程保存：
定时任务保存：

# 远程加载资源
  js

# 组件化建设
物料生产流程
1、开发阶段：
  源码；scheme协议；storybook（文档，测试用例）

2、构建阶段：
  纯净产物：umd esm模块
  平台产物：
  文档产物
  物料包产物：一些依赖信息

3、发布阶段：
oss+cdn
npm
静态文档部署

物料平台：聚合以上的地址方便管理

工程化：物料生产抽离为模版工程，该工程包含构建部署等功能

# pro code的产出

我们的页面都是dsl协议存在的，也就是scheme协议拼接而成，如何将DSL协议转化为react代码，利用模版引擎，比如nunjucks，将dsl协议转化为react代码，表达式等需要特殊处理
然后利用Prettier插件进行格式化输出可二次开发的代码

工程化：cli辅助工具：拉取组件执行的宿主模版工程，拉取完成执行cli命令根据站点id获取所有配置和页面协议，利用模版引擎转换成react源码然后输出在模版工程里。模版工程提供devops相关的服务，从而支持运行时预览与源码工程的发布部署预览。


